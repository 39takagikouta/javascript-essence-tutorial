1ブラウザとスレッド
スレッドとは、連続して実行される一本の処理の流れ
色々なスレッドがあるが、基本的にjsはメインスレッドというものの上で動く
これは、jsの実行とレンダリング（画面描画）を行う　多忙なスレッド
Fpsという概念がある　30〜60なら違和感がない　液晶テレビは60 60に近づけることが大事
思い処理があると、レンダリングに時間がかかる

2同期処理と非同期処理
動画がわかりやすい
同期処理ではメインスレッドで処理が順番に実行される　だから処理が完了するまで次には進まない
非同期処理は一時的にメインスレッドから処理が切り離される
具体例
非同期API
setTimeout
Promise
queueMicrotask

UIイベント
クリック

3タスクキュートとコールスタック
タスクキューとは実行待ちの非同期処理の行列　非同期処理の実行順を管理している
タスクに関するキューという箱
キューは先入先出　ロケット鉛筆方式
タスクキューとコールスタックは関連性がある
イベントループがコールスタックが開いているかを管理し、開いたら先入先出でタスクを入れてく

4コールバック関数と非同期処理
前者を使うことで、コールスタックとタスクキューの性質を利用して関数を実行する順序をコントロールすることができる（動画参照）

5非同期処理のチェーン
同じコールバック関数を何層にも書くことで非同期処理を連続して行うことができるが、promisのが便利らしい

6promise
よぶ側じゃなくて、関数によばれる側の関数がコールバック関数なんやな
使い方は動画を参照
とにかくpromis以外（then,catch,finally）は全て非同期処理

7promiseチェーン
チェーンを作るためにはreturnでpromiseのインスタンスを返すことが重要
また、then側でもreturnでpromiseの入った関数を実行し、promiseのインスタンスを返す
promiseで連鎖させる

8promiseと並列処理
promise.all
配列にはプロミスで帰ってきたインスタンスが入る
raceやallsettledもある

910マクロタスクとマイクロタスク
前者はこれまでのジョブキューに入っているもの
後者はタスクキューに入っているもの
前者より後者が優先される
前者が一つずつに対して、後者が全て一気に処理される
前者はsettimeout 後者はpromise
処理順のイメージは動画参照

11awaitとasync
両者はプロミスをさらに直感的にかけるようにしたもの
後者は、promiseを返却する関数の宣言を行う
前者は、promiseを返却する関数の非同期処理が完了するまで待つ
内部的にはpromiseと同じ
async自体が空のpromiseオブジェクトを返すので、thenをそのまま行うことができる

12fecth
jsonファイルの説明は動画参照
第一引数にurlを与える
重要な点
1promiseが返るので、thenが使える
2responceとは、jsonの情報が格納されているオブジェクト　jsonメソッドを使って情報を取得できる
ちなみに、responce.json()の部分もpromiseが帰っている
ブラウザが準備しているAPIもpromiseを返すことがたびたびある
思った通りの挙動にならない際は、console.logなどでどんなオブジェクトが返ってきているかを確認するといい

使い方は詳細
throwを使わずに、条件分岐の部分に直接エラーの出力を書いたらいいのでは？→コードの保守性が下がるらしい
エラーによって処理を分岐するためにカスタムエラーを作成する