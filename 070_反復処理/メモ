2ループ文
forとwhile

3演算子と優先順序
演算子とは、値をもとに処理を行い、「結果を返す（絶対）」記号
重要な点
1結果を返す
2順序
例を見ると分かりやすい
インクリメント++は、前につけるか後につけるかで挙動が変わる

4ループ文とブロックスコープ
ループごとにスコープが変わるので、ループの中でconstを定義したらそれぞれ別のメモリ先を参照する
varやループの外で変数を定義したときはずっと同じメモリ先を参照しているため変わらない

5配列とループ文
for文を使っていると、配列の中にfalsyな値0とかがあったらそこで止まる可能性がある（コード参照）

6for inと列挙可能性
enumerableがfalseだったら表示されない（ビルドインオブジェクトは基本falseだから設定したプロパティしか表示されない）
プロトタイプに格納されているものもオブジェクト
シンボルはenumerable関係なく表示されない

7for ofと反復可能性
ES6で導入
arrayが代表的
イテレーターはプロトタイプの中にあるプロパティ、for ofのときに使用される
enumerableを経由しないので、falseであっても関係なく表示される
for ofの挙動はイテレーターの挙動に依存する

8mapとset
両者はデータを管理するための入れ物＝コレクションともいう
object 制約あり　for in○ for ob×
map    制約なし　バツまる
setは重複値が使えないからarrayとは別の用途
パフォーマンスはmapの方がいい
変数に入っているのがプリミティブ型の場合は、値そのものへの参照を保持しているので、プロパティに代入した値自体を入れても対応する値を取ってくることができる
一方オブジェクトの場合は参照を保持しているので、プロパティに代入したオブジェクトを直接入れても別のものと識別され、対応する値を取り出すことはできない
mapとオブジェクトとは値の管理の方法が違う
Array.from(set)で配列にできる　スプレット構文でもいける

9イテレーター
反復操作を行う際に使用するオブジェクト
決められたルールに則って記述する
なんかあんまよくわからんかったから、課題の部分で理解する

10反復可能オブジェクト（イテレーター）
オブジェクトのプロトタイプの変更は推奨されていない　バグを生むから→じゃあ今はわからんでええわ

11ジェネレーター
こっちの方が断然直感的に使える
forofにもシンボルとか使わなくとも直接ofの後にジェネレーター関数を入れたらいいだけ
あんま使わんけど場合によっては大変強力らしい

12反復可能オブジェクト（ジェネレーター）
めっちゃ簡単になる

13スプレッド演算子とイテレーター
スプレッド演算子は新しい配列を作っているから、元の配列と比較してもfalseになる
スプレッド演算子は配列の括弧の中で使うとイテレータの動きに準拠する
{}の時はそうではない

完璧に理解はできなかった