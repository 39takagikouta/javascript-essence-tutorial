2コンストラクター関数
オブジェクトを大量に生成したい時に使用する
例）
function Person(name, age) {
  this.name = name このような形でプロパティと値を定義する
  this.age = age
}

const tom = new Person("tom", 20)
この処理をインスタンス化といい、できた変数をインスタンスという

3prototype
インスタンス化した際には、prototypeの参照が__proto__にコピーされる
コンストラクター関数の中に関数を直接定義すると、実行時にその関数ごとコピーされるのに対して、prototypeは参照だけコピーするのでメモリの節約になる
わけわからん　動かしてわかったこと（多分）
returnがオブジェクトの場合　オブジェクトの内容とプロトタイプは返らない（多分）
returnがプリミティブ型かreturnなしの場合　thisの内容とprototypeが返る

4instance_of
は、インスタンスがどのコンストラクタ関数によって作られたかを検証するもの
内部的な挙動としては、__proto__の参照先が同じかを調べている
だから、returnがオブジェクトの場合はfalseが出る
ArrayやObjectとかでも調べられる
具体的な使い方は、コンストラクタ関数から渡ってくるものがarrayかobjectかによって処理を分岐するといったもの


5関数constructor
constructor関数を作るやつ
注意点
1グローバルスコープを参照するので、普通の関数と同様に一番近いレキシカルスコープを参照しない
これは脆弱性の原因になるから基本的には関数宣言を使うらしい→じゃあいらんやんけ

6プロトタイプチェーン
Objectに直接prototypeを設定したら、全てのオブジェクトで使用することができる　全てこれから始まっているから
関数が呼び出された時、最も近いものを探す
例えば、最初にオブジェクトのプロパティを探し、なければそのコンストラクタに設定されているプロトタイプを探し、なければさらに浅い層のプロトタイプを探し、最終的にはobjectのものを探す
これにより、オブジェクト間でメソッドを共有することも可能　てか元からObjectにはプロトタイプで使えるメソッドが色々あるんやな　これがrubyでいうオブジェクトごとに使えるメソッドなんかな

7hasOwnpropertyとin
前者はそのオブジェクトのプロパティのみを調べるが、後者はプロトタイプチェーンも遡って調べてくれる

8プロトタイプ継承
コード参照
既存の関数から少し機能を拡張したものをすぐに作れるようになる

9クラス
コンストラクター関数をクラス表記で書けるようにしたもの
このような、既存の機能がより簡単に使えるようになったものをシンタックスシュガーという
jsでは、インスタンス化されたものは全てオブジェクト
基本的にはこれを使うが、裏側ではプロトタイプとかコンストラクタ関数が動いているので、その挙動を理解することは重要

10クラス継承
extendsとsuperで簡単に継承ができる

11super
関数コンテキスト内で使用できる　条件がかなり限られる
基本的にsuperは継承基の関数（コンストラクターやメソッド）を呼び出すためのキーワードとして使用される
クラスのコンストラクターも内部的にはコンストラクター関数が動いているのでコールスタックが発生する
{}で作成する初期化されたオブジェクトをオブジェクトリテラルという

12ビルドインオブジェクト
コード実行前にエンジンが自動的に作成するオブジェクト
grobalオブジェクトに格納されている。ほとんどがインスタンスを生成するためのコンストラクタ関数
本当はwindow.Arrayだが省略できる
配列もオブジェクトの一種　プロパティーが手前から1.2.3と自動で振ってくれている（プリミティブ型以外は全てオブジェクト）
配列も内部構造はオブジェクトであるというのは、他の言語との違い　だからプロトタイプも使える
newはオブジェクトに対して使う
ビルドインオブジェクトでもオブジェクトなので、プロトタイプとかコンストラクタとかに基づいて動作する
const string = new String("a");　こんなかんじでもオブジェクトになる
GPTに違いを聞いてみた

・質問
const string = new String("a");
const string = "a"
両者の違いを教えてください

・回答
JavaScriptでは、プリミティブ型とオブジェクト型の違いによって、同じように見えるデータでも内部的な扱いが異なります。`const string = new String("a");`と`const string = "a";`の違いは、前者がオブジェクト型であり、後者がプリミティブ型（文字列型）である点にあります。

### `new String("a")`について
`new String("a")`は、Stringオブジェクトを新しく生成します。これは文字列をラップするオブジェクトであり、Stringオブジェクトのメソッドやプロパティにアクセスできるようになります。しかし、オブジェクトとして生成されるため、プリミティブな文字列リテラルとは異なり、メモリの扱いや等価性の比較において異なる振る舞いをします。

### `"a"`について
`"a"`はプリミティブな文字列リテラルです。JavaScriptでは、このようなプリミティブな値は直接その値を表します。オブジェクトではないため、メモリがより効率的に使用され、文字列の操作や比較が簡単に行えます。また、プリミティブ型の文字列は、文字列リテラルとしてコード中に直接記述された値そのものを指します。

### 主な違い
- **型の違い**: `new String("a")`はオブジェクト型であり、`"a"`はプリミティブ型です。
- **等価性の比較**: `new String("a")`で生成されたオブジェクトは、別の`new String("a")`で生成されたオブジェクトと`===`（厳密等価演算子）で比較した場合に`false`を返します。これは、オブジェクトとしての参照が異なるためです。一方、プリミティブ型の文字列`"a"`は、別の`"a"`と`===`で比較した場合に`true`を返します。
- **パフォーマンス**: プリミティブ型の方がオブジェクト型に比べてメモリ使用効率が良いため、パフォーマンスの面で有利です。

通常、文字列を扱う際にはプリミティブ型の文字列リテラル（`"a"`）を使用するのが一般的です。`new String("a")`のようなオブジェクト型の文字列を使用する特別なケースは少なく、特定の目的（例えば、オブジェクトとしての文字列に特定のプロパティを追加するなど）がある場合に限られます。



そもそもnewがよくわからん
・newとは？
JavaScriptで`new`キーワードは、コンストラクタ関数から新しいオブジェクトを生成し、初期化するために使用されます。コンストラクタ関数は、特定のタイプのオブジェクトを作成するためのテンプレートのようなものです。`new`を使用することで、そのテンプレートに基づいて新しいオブジェクトインスタンスを作成し、そのインスタンスにプロパティやメソッドを設定することができます。

### `new`の基本的な使い方
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log("Hello, my name is " + this.name + "!");
  };
}

// 'new'を使ってPersonコンストラクタから新しいオブジェクトを生成する
const person1 = new Person("Alice", 30);
const person2 = new Person("Bob", 25);

// 新しいオブジェクトのメソッドを呼び出す
person1.greet(); // "Hello, my name is Alice!"
person2.greet(); // "Hello, my name is Bob!"
```

この例では、`Person`というコンストラクタ関数を定義しています。この関数内で`this`キーワードを使用して、新しく作成されるオブジェクトインスタンスにプロパティやメソッドを追加しています。`new Person("Alice", 30)`のように`new`キーワードと共にコンストラクタ関数を呼び出すことで、`Person`の新しいインスタンスが生成され、指定した名前と年齢のプロパティを持つ新しい`Person`オブジェクトが作成されます。

### `new`の動作
1. **新しいオブジェクトの作成**: `new`キーワードはまず空のオブジェクトを作成します。
2. **コンストラクタ関数の実行**: 次に、新しく生成されたオブジェクト（`this`）をコンテキストとしてコンストラクタ関数を実行します。これにより、新しいオブジェクトにプロパティやメソッドが設定されます。
3. **オブジェクトの返却**: 最後に、コンストラクタ関数が明示的にオブジェクトを返却しない場合、`new`によって生成されたオブジェクトが自動的に返却されます。

`new`を使用することで、同じ構造を持つオブジェクトを簡単に複数作成できるため、コードの再利用性が向上し、管理が容易になります。

12ラッパーオブジェクト
普通はプリミティブ型で定義する
正、stringやnumberで使えるメソッドは本来ラッパーオブジェクトに定義されたものであり、プリミティブ型に対してそれらのオブジェクトを使う場合は、暗黙的に内部でラッパーオブジェクトを経由している

13シンボル
Symbolという関数を用いて作成
Number（）などのコンストラクタ関数によるインスタンス化と違い、new演算子を用いないことに注意
プリミティブ型だが、文字列と違って一意だから、比較してもfalse
シンボルに名前をつけているだけ
Number（）とかはビルドインオブジェクトという
シンボルとは、es6に上がる際に既存で動いているコードを破壊しないために導入された、一意の値を得るためのプロパティ識別し
俺らは使わん→じゃあなんで学ぶねん　ガチすぎやろ

14ディスクリプター
それぞれのプロパティーにはディスクリプターが存在し、この設定値で挙動が変わる

15ゲッターとセッター
これもプロパティのオプション
ゲッターはそのプロパティの値が呼ばれたときに動くメソッド
セッターは新しい値がそのプロパティーに代入されたときに動くメソッド？
なんらかの処理を間に挟みたいときに使う
ES6からはクラスの中で簡単に設定できる
staticはスタティックメソッド、静的メソッドを定義する（rubyのクラスメソッド）
コンストラクタ関数にメソッドを追加するのとクラスに定義するのは同じ処理

16チェーンメソッド
一つのインスタンスに連続で処理をする場合に使う
それぞれのメソッドの返り値にthisを返すことで、次のメソッドも使えるようになる

補足
テンプレートリテラルとは
https://qiita.com/course_k/items/f535f27a6de5cc7962ba

プライベートプロパティ、プライベートメンバーとは
このクラスの中でしか使わないでください、ということを暗示している（開発者の暗黙の了解であり、実際に効果があるわけではない）
関数名の最初に_をつけるだけ
