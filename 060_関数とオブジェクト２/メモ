2コンストラクター関数
オブジェクトを大量に生成したい時に使用する
例）
function Person(name, age) {
  this.name = name このような形でプロパティと値を定義する
  this.age = age
}

const tom = new Person("tom", 20)
この処理をインスタンス化といい、できた変数をインスタンスという

3prototype
インスタンス化した際には、prototypeの参照が__proto__にコピーされる
コンストラクター関数の中に関数を直接定義すると、実行時にその関数ごとコピーされるのに対して、prototypeは参照だけコピーするのでメモリの節約になる
わけわからん　動かしてわかったこと（多分）
returnがオブジェクトの場合　オブジェクトの内容とプロトタイプのは返らない（多分）
returnがプリミティブ型かreturnなしの場合　thisの内容とprototypeが返る

4instance_of
は、インスタンスがどのコンストラクタ関数によって作られたかを検証するもの
内部的な挙動としては、__proto__の参照先が同じかを調べている
だから、returnがオブジェクトの場合はfalseが出る
ArrayやObjectとかでも調べられる
具体的な使い方は、コンストラクタ関数から渡ってくるものがarrayかobjectかによって処理を分岐するといったもの


5関数constructor
constructor関数を作るやつ
注意点
1グローバルスコープを参照するので、普通の関数と同様に一番近いレキシカルスコープを参照しない
これは脆弱性の原因になるから基本的には関数宣言を使うらしい→じゃあいらんやんけ

6プロトタイプチェーン
Objectに直接prototypeを設定したら、全てのオブジェクトで使用することができる　全てこれから始まっているから
関数が呼び出された時、最も近いものを探す
例えば、最初にオブジェクトのプロパティを探し、なければそのコンストラクタに設定されているプロトタイプを探し、なければさらに浅い層のプロトタイプを探し、最終的にはobjectのものを探す
これにより、オブジェクト間でメソッドを共有することも可能　てか元からObjectにはプロトタイプで使えるメソッドが色々あるんやな　これがrubyでいうオブジェクトごとに使えるメソッドなんかな

7hasOwnpropertyとin
前者はそのオブジェクトのプロパティのみを調べるが、後者はプロトタイプチェーンも遡って調べてくれる

8プロトタイプ継承
コード参照
既存の関数から少し機能を拡張したものをすぐに作れるようになる

9クラス
コンストラクター関数をクラス表記で書けるようにしたもの
このような、既存の機能がより簡単に使えるようになったものをシンタックスシュガーという
jsでは、インスタンス化されたものは全てオブジェクト
基本的にはこれを使うが、裏側ではプロトタイプとかコンストラクタ関数が動いているので、その挙動を理解することは重要

10クラス継承
extendsとsuperで簡単に継承ができる

11super
関数コンテキスト内で使用できる　条件がかなり限られる
基本的にsuperは継承基の関数（コンストラクターやメソッド）を呼び出すためのキーワードとして使用される
クラスのコンストラクターも内部的にはコンストラクター関数が動いているのでコールスタックが発生する
{}で作成する初期化されたオブジェクトをオブジェクトリテラルという